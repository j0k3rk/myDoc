= C# & .NET
:icons:
:toc:
:numbered:

== c#基础

=== 类型

==== 值类型

. 整型（8种）：
+
[options="autowidth"]
|===
|Name |CTS Type |Description |Range (min:max)
|sbyte |System.SByte |8-bit signed integer |-128:127 (-2^7^:2^7^–1)
|short |System.Int16 |16-bit signed integer |-32,768:32,767 (-2^15^:2^15^–1)
|int |System.Int32 |32-bit signed integer |-2,147,483,648:2,147,483,647 (-2^31^:2^31^–1)
|long |System.Int64 |64-bit signed integer |-9,223,372,036,854,775,808:9,223,372,036,854,775,807 (-2^63^:2^63^–1)
|byte |System.Byte |8-bit unsigned integer |0:255 (0:2^8^–1)
|ushort |System.UInt16 |16-bit unsigned integer |0:65,535 (0:2^16^–1)
|uint |System.UInt32 |32-bit unsigned integer |0:4,294,967,295 (0:2^32^–1)
|ulong |System.UInt64 |64-bit unsigned integer |0:18,446,744,073,709,551,615 (0:2^64^–1)
|===

. 浮点类型（2种）：
+
[options="autowidth"]
|===
|Name |CTS Type |Description |Significant Figures |Range (Approximate)
|float |System.Single |32-bit, single-precision floating point |7 |±1.5 × 10^245^ to ±3.4 × 10^38^
|double |System.Double |64-bit, double-precision floating point |15/16 |±5.0 × 10^2324^ to ±1.7 × 10^308^
|===

. decimal 类型：
+
[options="autowidth"]
|===
|Name |CTS Type |Description |Significant Figures |Range (Approximate)
|decimal |System.Decimal |128-bit, high-precision decimal notation |28 |±1.0 × 10^228^ to ± 7.9 × 10^28^
|===

. bool 类型：
+
[options="autowidth"]
|===
|Name |CTS Type |Description |Significant Figures |Range (Approximate)
|bool |System.Boolean |Represents true or false |NA |true or false
|===

. 字符类型：
+
[options="autowidth"]
|===
|Name |CTS Type |Values
|char |System.Char |Represents a single 16-bit (Unicode) character
|===

- 特殊符号：
+
[options="autowidth"]
|===
|Escape Sequence |Character
|\' |Single quotation mark
|\" |Double quotation mark
|\\ |Backslash
|\0 |Null
|\a |Alert
|\b |Backspace
|\f |Form feed
|\n |Newline
|\r |Carriage return
|\t |Tab character
|\v |Vertical tab
|===

==== 引用类型

. object 类型：
+
[options="autowidth"]
|===
|Name |CTS Type |Description
|object |System.Object |The root type. All other types (including value types) in the CTS are derived from object.
|===

. string 类型：
+
[options="autowidth"]
|===
|Name |CTS Type |Description
|string |System.String |Unicode character string
|===

- 字符串格式化
+
[options="autowidth"]
|===
|代码 |说明
|C |本地货币格式
|D |十进制格式，把整数转为以10为基数的数，如给定精度说明符，则加上前导0
|E |科学记数法（指数）格式，精度说明符设置小数位数（默认为6），格式字符的大小写（e或E）确定指数符号的大小写
|F |固定点格式，精度说明符设置小数位数，可为0
|G |普通格式，使用E或F格式取决于哪种格式较简单
|N |数字格式，加逗号表示千分符
|P |百分数格式
|X |十六进制格式，精度说明符用于加上前导0
|===

=== 修饰符

. 可见性修饰符
+
[options="autowidth"]
|===
|修饰符 |应用于 |说明
|public |所有类型或成员 |任何代码均可以访问
|protected |类型和内嵌类型的所有成员 |只有派生的类型能访问
|internal |所有类型或成员 |只能在包含它的程序集中访问
|private |类型和内嵌类型的所有成员 |只能在它所属的类型中访问
|protected internal |类型和内嵌类型的所有成员 |只能在派生类型和包含它的程序集中访问
|===

. 其他修饰符
+
[options="autowidth"]
|===
|修饰符 |应用于 |说明
|new |函数成员 |成员用相同的签名隐藏继承的成员
|static |所有成员 |成员不作用于类的具体实例
|virtual |仅函数成员 |成员可以由派生类重写
|abstract |仅函数成员 |虚拟成员定义了成员的签名，但不提供实现
|override |仅函数成员 |成员重写了继承的虚拟或抽象成员
|sealed |类、方法和属性 |对于类，不能被继承。对于方法和属性，成员可重写继承的虚拟成员，但不能被任何派生类的任何成员所重写。必须和 override 一起使用。
|extern |仅静态[dll import]方法 |成员在外部用不同的语言实现。
|===

=== XML 文档

使用3斜杠（///）注释的内容可以被自动提取创建为 XML 格式的文档说明。

- 特殊标记
+
[options="autowidth"]
|===
|标记 |说明
|<c> |把行中的文本标记为代码
|<code> |把多行标记为代码
|<example> |标记为一个代码示例
|<exception> |说明一个异常类（编译器要验证其语法）
|<include> |包含其他文档说明文件的注释（编译器要验证其语法）
|<list> |把列表插入文档中
|<para> |Gives structure to text
|<param> |标记方法的参数（编译器要验证其语法）
|<paramref> |表示一个单词是方法的参数（编译器要验证其语法）
|<permission> |说明对成员的访问（编译器要验证其语法）
|<remarks> |给成员添加描述
|<returns> |说明方法的返回值
|<see> |提供对另一个参数的交叉引用（编译器要验证其语法）
|<seealso> |提供描述中的“参见”部分（编译器要验证其语法）
|<summary> |提供类型或成员的简短小结
|<typeparam> |用在泛型类型的注释中以说明一个类型参数
|<typepararef> |类型参数的名称
|<value> |描述属性
|===

=== 预处理器指令

- #define 和 #undef
- #if 、 #elif 、 #else 和 #endif
- #warning 和 #error
- #region 和 #endregion
- #line
- #pragma

=== LINQ

- 一些有用的 LINQ 扩展方法
+
[options="autowidth"]
|===
|扩展方法 |描述 |延迟
|All |如果源数据中的所有条目都与谓词匹配，则返回 true |否
|Any |如果源数据中至少有一个条目与谓词匹配，则返回 true |否
|Contains |如果数据源含有指定的条目或值，则返回 true |否
|Count |返回数据源中的条目数 |否
|First |返回数据源的第一个条目 |否
|FirstOrDefault |返回数据源的第一个条目，或无条目时，返回默认值 |否
|Last |返回数据源的最后一个条目 |否
|LastOrDefault |返回数据源的最后条目，或无条目时，返回默认值 |否
|Max / Min |返回由 lambda 表达式表示的最大值或最小值 |否
|OrderBy / OrderByDescending |基于 lambda 表达式返回的值对数据源进行排序 |是
|Reverse |反转数据源中数据项的顺序 |是
|Select |设计一个查询结果 |是
|SelectMany |把每个数据项投射到一个条目序列之中，然后把所有这些结果序列连接成一个序列 |是
|Single |返回数据源的第一个条目，或者有多个匹配时抛出一个异常 |否
|SingleOrDefault |返回数据源的第一个条目，或者无条目时，返回默认值；有多个匹配条目时，抛出一个异常 |否
|Skip / SkipWhile |跳过指定数目的元素，或者当谓词匹配时跳过 |是
|Sum |对谓词选定的值求和 |否
|Take / TakeWhile |从数据源的开始处选择指定数目的元素，或当谓词匹配时选择条目 |是
|ToArray / ToDictionary / ToList |把数据源转换成数组或其他集合类型 |否
|Where |过滤掉数据源中与谓词不匹配的条目 |是
|===

=== ASP.NET MVC 5

. Razor 视图引擎

.. 声明视图模型对象的类型使用了 @model （首字母小写），而访问 Name 属性使用了 @Model （首字母大写）。
+
----
@model Razor.Models.Product
...
<div>
    @Model.Name
</div>
...
----

.. Views 文件夹中以下划线（_）开头的文件不会返回给用户，可以通过文件名来区分要进行渲染的视图和对视图进行支持的文件（例如视图布局文件）。

.. 如果视图是自包含的，且不想使用布局，应将 Layout 属性设置为 null 。如果忽略 Layout 属性，MVC 框架将使用视图起始文件（_ViewStart.cshtml）。

. 控制器类总是以 Controller 结尾，而在对类进行引用时，要忽略类名的 Controller 部分。
+
例如：ProductController 在路由配置文件 RouteConfig.cs 中引用时，应使用 Product。

=== 依赖注入

==== Ninject

. 常用条件绑定
+
[options="autowidth"]
|===
|方法 |效果
|When(谓词) | 当谓词（一个 lambda 表达式）的结果为 true 时，实施绑定
|WhenClassHas<T>() |当被注入的类以注解属性进行注释，而其类型为 T 时，实施绑定
|WhenInjectedInto<T>() |当要被注入的类是类型 T 时，实施绑定
|===

. 常用作用域方法
+
[options="autowidth"]
|===
|名称 |效果
|InTransientScope() |与未指定作用域效果相同，为每一个被解析的依赖项创建一个新的对象（每依赖项一实例）
|InSingletonScope() +
ToConstant(object) |创建一个单一实例，使其共享于整个应用程序。如果使用 InSingletonScope ，或者为 Ninject 提供 ToConstant 方法，Ninject 便会创建这种实例（每应用一实例）
|InThreadScope() |创建一个单一实例，将其用于解析一个线程中各个对象的依赖项（每线程一实例）
|InRequestScope() |创建一个单一实例，用于解析一个 HTTP 请求中各个对象的依赖项（每请求一实例）
|===

=== 编程规则

. 命名规则

.. 公有属性采用 Pascal 大小写形式命名，如果存在一个等价的私有字段，则采用 camel 大小写形式命名。把下划线(_)作为前缀，会为识别字段提供极大便利。
.. 接口名称通常以字母 I 开头。


=== 使用 `csc.exe` 编译：

- 选项
+
[options="autowidth"]
|===
|选项 |输出
|/t:exe   |控制台应用程序（默认）
|/t:library  |带有清单的类库
|/t:module  |没有清单的组件
|/t:winexe  |Windows应用程序（无控制台窗口）
|/out |指定编译后生成的输出文件名
|/r (/reference) |指定引用库
|===
+
举例：
+
----
// 生成dll
csc /t:library MathLibrary.cs

// 生成exe
csc MathClient.cs /r:MathLibrary.dll

// 执行exe
MathClient.exe
----

=== 其他知识点

. 运算符计算顺序举例：
+
----
int a = 5;
int b = a++ + (++a) * 2 + ++a;  // b = 5 + 7 * 2 + 8 = 27
----

. 除非特别指定，C#的所有引用类型都通过引用来传递，所有值类型都通过值来传递。

    - 强制值参数通过引用传递给方法，可以使用 `ref` 关键字，例如：
+
----
static void SomeFunction(int[] ints, ref int i) {
    ints[0] = 100;
    i = 100; // The change to i will persist after SomeFunction() exits.
}

SomeFunction(ints, ref i);
----

    - 在方法的输入参数前加上 out 前缀，传递给该方法的变量可以不初始化。
+
----
static void SomeFunction(out int i) {
    i = 100;
}

public static int Main() {
    int i; // note how i is declared but not initialized.
    SomeFunction(out i);
    Console.WriteLine(i);
    return 0;
}
----

. 如果提供了带参数的 `构造函数` ，编译器就不再自动提供默认的构造函数。

.. 类有一些静态字段或属性，需要在第一次使用类之前从外部源中初始化，可以使用 `静态构造函数` 。

... 静态构造函数总是由.NET运行库调用，所以没有访问修饰符（无意义）
... 不能带任何参数
... 一个类只有一个静态构造函数
... 只能访问类的静态成员，不能访问实例成员
... 静态构造函数和无参数的实例构造函数可以在同一个类中定义，加载类时执行前者，创建实例时执行后者。
... 若多个类中都有静态构造函数，先执行哪个无法确定。一个静态构造函数中的代码不应依赖于其他静态构造函数。

. 只读字段

.. readonly 关键字比 const 更灵活，可以在构造函数中赋值，但不能在其他地方赋值。
.. 可以是实例字段，而不是静态字段，类的每个实例可以有不同的值。
.. 如果要把只读字段设置为静态，必须显式声明。

. 弱引用

- 实例化一个类或结构时，只要有代码引用它，就会形成强引用，垃圾回收器不会清理 MyClass 对象使用的内存。
+
----
MyClass myClassVariable = new MyClass();
----

- 如果类对象很大又不经常访问，（特殊情况下）可以创建对象的弱引用（WeakReference）。

. System.Object()方法
- ToString()
- GetHashCode()
- Equals() 和 ReferenceEquals()
- Finalize()
- GetType()
- MemberwiseClone()

. 继承

.. 继承的类型
... 实现继承
... 接口继承

.. 不支持多重实现继承，允许多重接口继承。

.. 不支持私有继承。

.. 虚方法
+
把基类函数声明为 virtual，就可以在任何派生类中重写该函数。（override）

.. 隐藏方法
+
如果签名相同的方法在基类和派生类中都进行了声明，但没有分别使用 virtual 和 override，派生类方法就会隐藏基类方法。

.. 调用函数的基类版本：base.Function()

.. 抽象类和抽象函数（abstract）
+
- 抽象类不能实例化。
- 抽象函数不能直接实现，必须在非抽象的派生类中实现。
- 抽象函数本身也是虚拟的（不需要提供 virtual 关键字）。
- 如果类包含抽象函数，则该类也是抽象的，必须相应声明。

.. 密封类和密封方法（sealed）
- 对于类，表示不能继承该类。
- 对于方法，表示不能重写该方法。
- 要在方法或属性上使用 sealed 关键字，必须先重写于一个基类。如果基类上不希望有重写的方法或属性，就不要声明为 virtual。

. 扩展方法必须为静态，且必须在静态类中定义。

=== FAQ

[qanda]

`class` 和 `struct` 的区别？::
    * `class` 是存储在堆（heap）上的引用类型，而 `struct` 是存储在栈（stack）上的值类型。
    * `struct` 不支持继承。（唯一例外是最终派生于 System.Object，继承链为：* <- System.ValueType <- System.Object）
    * `struct` 不允许定义无参数的构造函数。（编译器总是提供一个无参数的默认构造函数，不允许替换。）
    * 较小的数据类型使用 `struct` 可以提高性能。
    * `struct` 可以指定字段如何在内存中布局。

xxxxx::
xxx


== ASP.NET基础

. Web窗体代码片段类型
+
[options="autowidth"]
|===
|代码 |含义
|<%   |表示标准代码片段，其中包含由ASP.NET Framework计算的代码语句。如果希望发送给浏览器的响应中包含HTML，则必须在代码片段中使用Response.Write方法。
|<%=  |表示内容代码片段。与标准代码片段相似，但其结果将被插入到发送给浏览器的响应中，无需显式调用Response.Write。
|<%:  |表示已编码代码片段。类似于<%=，但响应将进行HTML编码。
|<%#  |表示数据绑定代码片段，用于引用当前数据对象。
|<%#: |表示已编码数据绑定代码片段，期中的数据绑定值已编码。
|<%$  |属性代码片段。用于引用配置值（如那些在Web.config中定义的值）。
|<%@  |表示指令，用于配置Web窗体（或控件和母版页，具体因指令的类型而异）。
|===

. HttpApplication类定义的请求生命周期事件

+
[options="autowidth"]
|===
|名称 |说明

|[aqua]#Start#
|Application_Start

|BeginRequest
|ASP.NET Framework收到新请求时触发的第一个事件

|AuthenticateRequest PostAuthenticateRequest
|当ASP.NET Framework需要识别提出请求的用户时，将触发AuthenticateRequest事件。处理完所有事件处理程序后，将触发PostAuthenticateRequest事件

|AuthorizeRequest PostAuthorizeRequest
|当ASP.NET Framework需要授权请求时，将触发AuthorizeRequest事件。处理完所有事件处理程序后，将触发PostAuthorizeRequest事件

|ResolveRequestCache PostResolveRequestCache
|当ASP.NET Framework需要解析缓存数据中的请求时，将触发ResolveRequestCache事件。处理完所有事件处理程序后，将触发PostResolveRequestCache事件

|MapRequestHandler PostMapRequestHandler
|当ASP.NET Framework需要为请求查找处理程序时，将触发MapRequestHandler事件。选择处理程序后，将触发PostMapRequestHandler事件

|[aqua]#Session_Start#
|Session_Start

|AcquireRequestState PostAcquireRequestState
|当ASP.NET Framework需要与请求关联的状态（会话状态）时，将触发AcquireRequestState事件。处理完所有事件处理程序后，将触发PostAcquireRequestState事件

|PreRequestHandlerExecute
|在要求处理程序处理请求之前，会立即触发这些事件

|[aqua]#显示页面#
|-

|PostRequestHandlerExecute
|在要求处理程序处理请求之后，会立即触发这些事件

|ReleaseRequestState PostReleaseRequestState
|当ASP.NET Framework不再需要与请求关联的状态时，将触发ReleaseRequestState事件。处理完所有事件处理程序后，将触发PostReleaseRequestState事件。

|UpdateRequestCache
|触发此事件以便负责缓存的模块更新其状态。

|LogRequest PostLogRequest
|当ASP.NET Framework需要记录此请求的详细信息时，将触发LogRequest事件。处理完所有事件处理程序后，将触发PostLogRequest事件。

|EndRequest
|当ASP.NET Framework处理完请求、准备向浏览器发送响应时，将触发EndRequest事件

|PreSendRequestHeaders
|将在向浏览器发送HTTP标头之前触发PreSendRequestHeaders事件

|PreSendRequestContent
|将在发送标头之后、在向浏览器发送内容之前触发PreSendRequestContent事件

|[aqua]#Error#
|将在遇到错误时触发Error事件——处理请求的任何阶段都可能发生此事件

|[aqua]#End#
|Application_End
|===

. HttpContext 成员

+
[options="autowidth"]
|===
|名称 |说明

|Application
|返回用于管理应用程序状态数据的HttpApplicationState对象

|ApplicationInstance
|返回与当前请求关联的HttpApplication对象

|Cache
|返回用于缓存响应数据的Cache对象

|Current
|（静态）返回当前请求的HttpContext对象

|IsDebuggingEnabled
|如果已将调试器附加到Web窗体应用程序，则返回true。可以将此成员用于执行特定于调试的操作，但如果要这样做，部署之前请在不使用调试器的情况下进行全面测试。

|Items
|返回可用于在参与处理请求的ASP.NET Framework组件之间传递状态数据的集合

|GetSection(name)
|从Web.config文件中获取指定的配置部分

|Profile
|返回用于访问每个用户配置文件数据的ProfileBase对象。并非所有的安全模块都会设置此值，因此，应该使用ProfileBase.Create方法

|Request
|返回提供所处理的请求的详细信息的HttpRequest对象

|Response
|返回一个HttpResponse对象，该对象提供正在构建并将发送到浏览器的响应的详细信息

|Session
|返回用于访问会话状态的HttpSession状态对象。此属性将返回null，直到触发PostAcquireRequestState应用程序事件

|Server
|返回一个HttpServerUtility对象，其中可能包含实用功能，最有用的功能包括：用于对字符串进行安全编码已将其作为HTML显示的方法，以及用于控制请求处理程序执行的功能

|TimeStamp
|返回一个DateTime对象，其中包含创建HttpContext对象的时间

|User
|返回用于访问有关请求的安全信息的IPrincipal接口实现
|===

. HttpApplication 成员

+
[options="autowidth"]
|===
|名称 |说明

|Application
|与HttpContext.Application属性对应

|CompleteRequest()
|废弃当前请求的生命周期，直接转到EndRequest事件

|Context
|返回当前请求的HttpContext对象

|Init()
|在每个注册的模块上调用Init方法后调用

|Modules
|返回提供应用程序中模块详细信息的HttpModuleCollection对象

|RegisterModule(type)
|添加一个新模块

|Request
|返回HttpContext.Request的值，但如果该值为null，将抛出HttpException

|Response
|返回HttpContext.Response的值，但如果该值为null，将抛出HttpException

|Server
|与HttpContext.Server属性对应

|Session
|返回HttpContext.Session的值，但如果该值为null，将抛出HttpException

|User
|返回HttpContext.User的值，但如果该值为null，将抛出HttpException
|===

. HttpRequest 属性

+
[options="autowidth"]
|===
|名称 |说明

|AcceptTypes
|返回浏览器接受的MIME类型的字符串数组

|Browser
|返回描述浏览器功能的HttpBrowserCapabilities对象

|ContentEncoding
|返回一个System.Text.Encoding对象，该对象表示用于对请求数据进行编码的字符集

|ContentLength
|返回请求中内容的字节数

|ContentType
|返回请求中内容的MIME类型

|Cookies
|返回包含请求中的cookie的HttpCookieCollection对象

|Files
|返回浏览器在窗体中发送的文件的集合

|Form
|用于访问窗体数据

|Headers
|返回一个包含请求头的集合

|HttpMethod
|返回用于提出请求的HTTP方法（GET、POST等）

|InputStream
|返回可用于读取请求内容的流

|IsLocal
|如果请求源自本地计算机，则返回true

|Params
|查询字符串、窗体字段和cookie中的组合数据项的集合。也可以直接在HttpRequest对象上使用数组风格的索引器，以使Request[“myname”]与Request.Params[“myname”]相同

|QueryString
|返回查询字符串参数的集合

|RawUrl
|返回URL中域名之后的部分

|Url
|以System.Uri对象的形式返回请求URL

|UrlReferrer
|以System.Uri对象的形式返回引用URL

|UserAgent
|返回浏览器提供的用户代理字符串

|UserHostAddress
|返回远程客户端的IP地址（用字符串表示）

|UserHostName
|返回远程客户端的DNS名称

|UserLanguages
|返回浏览器/用户首选的语言的字符串数组
|===

. HttpResponse 属性

+
[options="autowidth"]
|===
|名称 |说明

|AppendCookie(cookie)
|用于将cookie添加到集合中的便捷方法

|AppendHeader(name, val)
|用于在响应中添加新头部的便捷方法

|BufferOutput
|获取或设置一个值，表明是否应在将请求发送给浏览器之前完全缓冲请求，默认值为true。如果将此值更改为false，随后的模块和处理程序将无法更改响应

|Cache
|返回为响应指定缓存策略的HttpCachePolicy对象

|CacheControl
|获取或设置响应的cache-control HTTP标头

|Charset
|获取或设置为响应指定的字符集

|Clear() ClearContent()
|这些方法是等价的，用于从响应中删除内容

|ClearHeaders()
|从响应中删除所有头部

|ContentEncoding
|获取或设置响应中内容的编码

|Cookies
|获取响应的cookie集合

|Headers
|返回响应头的集合

|IsClientConnected
|如果客户端仍连接到服务器，则返回true

|IsRequestBeingDirected
|如果将向浏览器发送重定向，则返回true

|Output
|返回可用于向响应中写入文本的TextWriter

|OutputStream
|返回可用于向响应中写入二进制数据的Stream

|RedirectLocation
|获取或设置HTTP Location头的值

|Status
|获取或设置响应的状态，默认值为200(OK)

|StatusCode
|获取或设置状态的数字部分，默认值为200

|StatusDescription
|获取或设置状态的文本部分，默认值为(OK)

|SuppressContent
|如果设置为true，会避免将响应内容发送给客户端

|Write(data)
|将数据写入到响应输出流中

|WriteFile(path)
|将指定文件的内容写入到输出流中
|===

. HttpModulesCollection 属性

+
[options="autowidth"]
|===
|名称 |说明

|AllKeys
|返回一个包含所有已注册模块名称的字符串数组

|Count
|返回已注册的模块数
|===

. 模块(Module)与处理程序(Handler)的选择

    - 定制现有应用处理响应的方式，使用模块。
    - 创建新的Web应用，使用处理程序。
    - 模块为处理程序准备请求，处理程序为客户端生成响应。不要在模块中生成响应，也不要在处理程序中实现请求功能（如状态管理和安全性）。

. System.Web.UI.Page类事件

+
[options="autowidth"]
|===
|名称 |说明

|PreInit
|在ASP.NET Framework调用由IHttpHandler接口定义的ProcessRequest方法后触发。此事件用于配置页面，通常通过设置与Page指令中的特性对应的属性的值来完成操作

|Init
|在将页面中的所有控件发送给Initial事件后触发

|InitComplete
|在设置视图状态时触发。在触发此事件之前分配的视图状态数据值将会丢失

|PreLoad
|在处理请求中的数据后触发。这些数据包括视图状态和表单数据

|Load
|在将Load事件发送给Web窗体中的控件之前触发。此事件有助于设置控件所需的资源（如数据库）

|LoadComplete
|在执行所有控件的事件处理程序后触发。这包括控件Load事件以及控件触发的任何自定义事件

|PreRender
|在从Web窗体生成HTML响应之前触发。此事件用于对Web窗体内容、可编程HTML元素或它包含的控件做出最终调整

|PreRenderComplete
|在将PreRender事件发送给Web窗体包含的控件后调用

|SaveStateComplete
|在保存状态数据（包括视图和会话状态）后触发。在触发此事件之后对状态所做的更改将会丢失，但它们将会影响HTML响应

|Unload
|在生成HTML响应以便释放Web窗体使用的所有资源（如数据库连接）后触发

|Error
|在Web窗体或它包含的其中一个控件中出现未经处理的异常时触发。此事件可以在事件序列的任何位置触发
|===

. 发送给控件的事件

+
[options="autowidth"]
|===
|名称 |说明

|Init
|在首次初始化控件时触发。处理此事件可执行基本的初始化，如设置数据库连接。可以访问有关请求的基本信息，但视图状态和表单数据不可用。不要尝试访问其他控件，因为它们可能尚未初始化

|Load
|在视图状态和表单数据可用时触发。可以定位Web窗体中的其他控件并与其交互

|PreRender
|在调用Render方法来为响应生成HTML片段之前触发。处理此事件可设置要生成的内容，包括管理包含在标记中的嵌套控件

|Unload
|在呈现过程之后调用。处理此事件可释放一直使用的任何资源，如数据库连接
|===


== ADO.NET 连接 AS/400 测试记录

- 环境需求：
    * Entity Framework 6 Tools
    * DB2 Connect 10.5 FP6（最新版为11.1）
    * NuGet包：
+
----
Install-Package EntityFramework.IBM.DB2
----

- 安装 DB2 Connect 10.5 FP6 时遇到的问题：

    * 收费产品需购买版权

    * 先安装驱动包（若直接安装 vs add-ins 会提示缺少驱动。

    * 安装驱动包后，可以在cmd窗口中使用如下命令检测：
+
----
db2cli validate
----

    * 安装 vs add-ins 时会自动注册（或事后手动注册），出现提示 vs 2010 shell 授权数据无效。

    ** 卸载 vs2010 shell isolated 后重新注册成功。
    ** 此shell是安装 SQL Server 2014 时产生的，卸载后 SSMS 无法正常启动，可下载独立安装包重装解决。