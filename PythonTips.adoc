=== 备忘知识点（ref: www.liaoxuefeng.com）

. 特殊符号，特殊值，操作符

.. \
+
转义符

.. r'\\'
+
使用r后，引号内部的字符串不转义

.. '''...'''
+
交互模式下，三个引号可以表示多行内容

.. None
+
空值是Python里一个特殊的值，用None表示。

.. inf（无限大）
+
整数没有大小限制。浮点数也没有大小限制，但超出一定范围就直接表示为inf（无限大）。

.. //
+
取整除法，返回商的整数部分。

.. %
+
取模，返回除法的余数。

. 变量赋值
+
----
// 指针传递，打印结果为'ABC'。
a = 'ABC'
b = a
a = 'XYZ'
print(b)
----

. 字符串

.. 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符
+
----
>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'
----

.. 如果知道字符的整数编码，还可以用十六进制
+
----
>>> '\u4e2d\u6587'
'中文'
----

.. 以Unicode表示的str通过encode()方法可以编码为指定的bytes
+
----
>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
----

.. 把bytes变为str，需要用decode()方法
+
----
>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
----

.. len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数
+
----
>>> len('ABC')
3
>>> len('中文')
2
>>> len(b'ABC')
3
>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
6
>>> len('中文'.encode('utf-8'))
6
----

.. 为了避免乱码问题，应始终坚持使用UTF-8编码对 str 和 bytes 进行转换。通常在Python源代码文件开头写上如下两行
+
----
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
----

. 格式化

.. 常见占位符
+
|===
|%d |整数
|%f |浮点数
|%s |字符串
|%x |十六进制整数
|%% |转义，表示一个%
|===

.. 格式化整数和浮点数还可以指定是否补0和整数与小数的位数
+
----
>>> '%2d-%02d' % (3, 1)
' 3-01'
>>> '%.2f' % 3.1415926
'3.14'
----

. tuple

.. 因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这种情况下，按小括号进行计算。
要定义一个只有1个元素的tuple，定义时必须加一个逗号,，来消除歧义。
+
----
>>> t = (1)
>>> t
1
>>> t = (1,)
>>> t
(1,)
----

.. “可变的”tuple：tuple每个元素的“指向”不可改变，但指向的List允许改变，参考下例：
+
----
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
----

. pass
+
占位符

. 函数

.. 函数执行完毕也没有return语句时，自动return none。

.. 函数可以同时返回多个值，但其实就是一个tuple。

.. 默认参数
+
----
#  异常
def add_end(L=[]):
    L.append('END')
    return L

>>> add_end()
['END']
>>> add_end()
['END', 'END']

# 正常
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L

>>> add_end()
['END']
>>> add_end()
['END']
----

.. 可变参数
+
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。
+
----
#  给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……
def calc(*numbers):  #加个*即可
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

----

.. 关键字参数
+
关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
+
----
#  给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}

#  **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict。
#  注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
----

.. 命名关键字参数
+
如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。
+
----
#  特殊分隔符*后面的参数被视为命名关键字参数。
def person(name, age, *, city, job):
    print(name, age, city, job)

>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer

#  如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了。
def person(name, age, *args, city, job):
    print(name, age, args, city, job)

#  由于命名关键字参数city具有默认值，调用时，可不传入city参数
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)

>>> person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
----

.. 参数组合

... 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

... 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。
.... *args是可变参数，args接收的是一个tuple；
.... **kw是关键字参数，kw接收的是一个dict。

. 高级特性

.. 切片
+
L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
如果第一个索引是0，还可以省略。

... 先创建一个0-99的数列：
+
----
>>> L = list(range(100))
>>> L
[0, 1, 2, 3, ..., 99]
----

... 前10个数：
+
----
>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
----

... 后10个数：
+
----
>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
----

... 前11-20个数：
+
----
>>> L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
----

... 前10个数，每两个取一个：
+
----
>>> L[:10:2]
[0, 2, 4, 6, 8]
----

... 所有数，每5个取一个：
+
----
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
----

... 只写[:]就可以原样复制一个list：
+
----
>>> L[:]
[0, 1, 2, 3, ..., 99]
----

... tuple也可以用切片操作，只是操作的结果仍是tuple：
+
----
>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
----

... 字符串也可以用切片操作，只是操作结果仍是字符串：
+
----
>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'
----

.. 迭代

... 除了有下标的list可以迭代，没有下标的dict也可以迭代。
.... 默认情况下，dict迭代的是key。
.... 如果要迭代value，可以用for value in d.values()。
.... 如果要同时迭代key和value，可以用for k, v in d.items()。

... 字符串也是可迭代对象。

... 判断一个对象是可迭代对象的方法是通过collections模块的Iterable类型判断：
+
----
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
----

... Python内置的enumerate函数可以把list变成索引-元素对，在for循环中同时迭代索引和元素本身：
+
----
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
----

.. 列表生成式

... 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
+
----
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
----

... 生成[1x1, 2x2, 3x3, ..., 10x10]
+
----
>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
----

... for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：
+
----
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
----

... 还可以使用两层循环，可以生成全排列：
+
----
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
----

... 列出当前目录下的所有文件和目录名，可以通过一行代码实现：
+
----
>>> import os # 导入os模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.idea', 'test1.py']
----

... for循环可以同时使用多个变量，比如dict的items()可以同时迭代key和value：
+
----
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
----

... 列表生成式也可以使用两个变量来生成list：
+
----
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
----

... 把一个list中所有的字符串变成小写：
+
----
>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
----


.. 生成器

... 斐波那契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：
1, 1, 2, 3, 5, 8, 13, 21, 34, ...

.... 用函数打印实现如下：
+
----
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print(b)
        a, b = b, a + b
        n = n + 1
    return 'done'
----

.... 要把fib函数变成generator，只需要把print(b)改为yield b就可以了：
+
----
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
----

... 杨辉三角举例实现
+
----
# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
for t in triangles():
    print(t)
    n += 1
    if n == 10:
        break

def triangles():
    mylist = [1]
    while True:
        yield mylist
        mylist.append(0)
        mylist = [mylist[i - 1] + mylist[i] for i in range(len(mylist))]
----


.. 迭代器

... 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

... 使用isinstance()可以判断一个对象是否是Iterator对象。
+
----
>>> from collections import Iterator
>>> isinstance((x for x in range(10)), Iterator)
True
>>> isinstance([], Iterator)
False
>>> isinstance({}, Iterator)
False
>>> isinstance('abc', Iterator)
False
----

... 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

... 把list、dict、str等Iterable变成Iterator可以使用iter()函数：
+
----
>>> isinstance(iter([]), Iterator)
True
>>> isinstance(iter('abc'), Iterator)
True
----

. 函数式编程

.. 高阶函数

... map/reduce

.... map()函数接收两个参数，一个是函数，一个是Iterable。
map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
+
函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：
+
----
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
----
+
----
>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
----

.... reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，
reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
+
----
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
----
+
例如对一个序列求和：
+
----
>>> from functools import reduce
>>> def add(x, y):
...     return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25
----
+
把序列[1, 3, 5, 7, 9]变换成整数13579：
+
----
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
----
+
配合map()，我们就可以写出把str转换为int的函数：
+
----
from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
----

... filter
+
filter()也接收一个函数和一个序列，把传入的函数依次作用于每个元素，
然后根据返回值是True还是False决定保留还是丢弃该元素。
+
用埃氏筛法计算素数的方法举例：
+
----
#  构造一个从3开始的奇数序列
def _odd_iter():
    n = 1
    while True:
        n += 2
        yield n

#  筛选函数
def _not_divisible(n):
    return lambda x: x % n > 0

#  定义一个生成器，不断返回下一个素数
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列

# 打印1000以内的素数:
for n in primes():
    if n < 1000:
        print(n)
    else:
        break
----

... sorted
+
sorted()函数可以对list进行排序，还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
+
----
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
----
+
忽略大小写的排序：
+
----
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
----
+
要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
+
----
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
----

.. 返回函数

.. 匿名函数

.. 装饰器

.. 偏函数




