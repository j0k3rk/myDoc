=== Anaconda

. 配置文件所在目录如下，如不存在可手动创建：
+
----
C:\Users\JohnDoe\.condarc

auto_update_conda: false
proxy_servers:
    http: http://user:password@proxy.server.com:8080
    https: http://user:password@proxy.server.com:8080
ssl_verify: False
----

. 简单用法
+
----
conda list
conda install package-name
----

=== Keras

. backend 切换
+
----
If you have run Keras at least once, you will find the Keras configuration file at:

~/.keras/keras.json

If it isn't there, you can create it.

The default configuration file looks like this:

{
    "image_dim_ordering": "tf",
    "epsilon": 1e-07,
    "floatx": "float32",
    "backend": "tensorflow"
}

Simply change the field backend to either "theano" or "tensorflow", and Keras will use the new configuration next time you run any Keras code.
----

=== 备忘知识点

. 运算符按优先级顺序列出如下：
.. 函数调用，寻址，下标
.. 幂运算**
.. 翻转运算~
.. 正负号+-
.. 乘*，除/，余%
.. 加减号+-
.. 左移<<，右移>>
.. 按位 与&，异或^，或|
.. 比较运算符
.. 逻辑 not and or
.. lambda表达式

=== LXF教程笔记（ref: www.liaoxuefeng.com）

. 特殊符号，特殊值，操作符

.. \
+
转义符

.. r'\\'
+
使用r后，引号内部的字符串不转义

.. '''...'''
+
交互模式下，三个引号可以表示多行内容

.. None
+
空值是Python里一个特殊的值，用None表示。

.. inf（无限大）
+
整数没有大小限制。浮点数也没有大小限制，但超出一定范围就直接表示为inf（无限大）。

.. //
+
取整除法，返回商的整数部分。

.. %
+
取模，返回除法的余数。

. 变量赋值
+
----
// 指针传递，打印结果为'ABC'。
a = 'ABC'
b = a
a = 'XYZ'
print(b)
----

. 字符串

.. 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符
+
----
>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'
----

.. 如果知道字符的整数编码，还可以用十六进制
+
----
>>> '\u4e2d\u6587'
'中文'
----

.. 以Unicode表示的str通过encode()方法可以编码为指定的bytes
+
----
>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
----

.. 把bytes变为str，需要用decode()方法
+
----
>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
----

.. len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数
+
----
>>> len('ABC')
3
>>> len('中文')
2
>>> len(b'ABC')
3
>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
6
>>> len('中文'.encode('utf-8'))
6
----

.. 为了避免乱码问题，应始终坚持使用UTF-8编码对 str 和 bytes 进行转换。通常在Python源代码文件开头写上如下两行
+
----
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
----

. 格式化

.. 常见占位符
+
|===
|%d |整数
|%f |浮点数
|%s |字符串
|%x |十六进制整数
|%% |转义，表示一个%
|===

.. 格式化整数和浮点数还可以指定是否补0和整数与小数的位数
+
----
>>> '%2d-%02d' % (3, 1)
' 3-01'
>>> '%.2f' % 3.1415926
'3.14'
----

. tuple

.. 因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这种情况下，按小括号进行计算。
要定义一个只有1个元素的tuple，定义时必须加一个逗号,，来消除歧义。
+
----
>>> t = (1)
>>> t
1
>>> t = (1,)
>>> t
(1,)
----

.. “可变的”tuple：tuple每个元素的“指向”不可改变，但指向的List允许改变，参考下例：
+
----
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
----

. pass
+
占位符

. 函数

.. 函数执行完毕也没有return语句时，自动return none。

.. 函数可以同时返回多个值，但其实就是一个tuple。

.. 默认参数
+
----
#  异常
def add_end(L=[]):
    L.append('END')
    return L

>>> add_end()
['END']
>>> add_end()
['END', 'END']

# 正常
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L

>>> add_end()
['END']
>>> add_end()
['END']
----

.. 可变参数
+
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。
+
----
#  给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……
def calc(*numbers):  #加个*即可
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

----

.. 关键字参数
+
关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
+
----
#  给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}

#  **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict。
#  注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
----

.. 命名关键字参数
+
如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。
+
----
#  特殊分隔符*后面的参数被视为命名关键字参数。
def person(name, age, *, city, job):
    print(name, age, city, job)

>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer

#  如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了。
def person(name, age, *args, city, job):
    print(name, age, args, city, job)

#  由于命名关键字参数city具有默认值，调用时，可不传入city参数
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)

>>> person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
----

.. 参数组合

... 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

... 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。
.... *args是可变参数，args接收的是一个tuple；
.... **kw是关键字参数，kw接收的是一个dict。

. 高级特性

.. 切片
+
L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
如果第一个索引是0，还可以省略。

... 先创建一个0-99的数列：
+
----
>>> L = list(range(100))
>>> L
[0, 1, 2, 3, ..., 99]
----

... 前10个数：
+
----
>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
----

... 后10个数：
+
----
>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
----

... 前11-20个数：
+
----
>>> L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
----

... 前10个数，每两个取一个：
+
----
>>> L[:10:2]
[0, 2, 4, 6, 8]
----

... 所有数，每5个取一个：
+
----
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
----

... 只写[:]就可以原样复制一个list：
+
----
>>> L[:]
[0, 1, 2, 3, ..., 99]
----

... tuple也可以用切片操作，只是操作的结果仍是tuple：
+
----
>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
----

... 字符串也可以用切片操作，只是操作结果仍是字符串：
+
----
>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'
----

.. 迭代

... 除了有下标的list可以迭代，没有下标的dict也可以迭代。
.... 默认情况下，dict迭代的是key。
.... 如果要迭代value，可以用for value in d.values()。
.... 如果要同时迭代key和value，可以用for k, v in d.items()。

... 字符串也是可迭代对象。

... 判断一个对象是可迭代对象的方法是通过collections模块的Iterable类型判断：
+
----
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
----

... Python内置的enumerate函数可以把list变成索引-元素对，在for循环中同时迭代索引和元素本身：
+
----
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
----

.. 列表生成式

... 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
+
----
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
----

... 生成[1x1, 2x2, 3x3, ..., 10x10]
+
----
>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
----

... for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：
+
----
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
----

... 还可以使用两层循环，可以生成全排列：
+
----
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
----

... 列出当前目录下的所有文件和目录名，可以通过一行代码实现：
+
----
>>> import os # 导入os模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.idea', 'test1.py']
----

... for循环可以同时使用多个变量，比如dict的items()可以同时迭代key和value：
+
----
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
----

... 列表生成式也可以使用两个变量来生成list：
+
----
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
----

... 把一个list中所有的字符串变成小写：
+
----
>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
----


.. 生成器

... 斐波那契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：
1, 1, 2, 3, 5, 8, 13, 21, 34, ...

.... 用函数打印实现如下：
+
----
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print(b)
        a, b = b, a + b
        n = n + 1
    return 'done'
----

.... 要把fib函数变成generator，只需要把print(b)改为yield b就可以了：
+
----
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
----

... 杨辉三角举例实现
+
----
# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
for t in triangles():
    print(t)
    n += 1
    if n == 10:
        break

def triangles():
    mylist = [1]
    while True:
        yield mylist
        mylist.append(0)
        mylist = [mylist[i - 1] + mylist[i] for i in range(len(mylist))]
----


.. 迭代器

... 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

... 使用isinstance()可以判断一个对象是否是Iterator对象。
+
----
>>> from collections import Iterator
>>> isinstance((x for x in range(10)), Iterator)
True
>>> isinstance([], Iterator)
False
>>> isinstance({}, Iterator)
False
>>> isinstance('abc', Iterator)
False
----

... 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

... 把list、dict、str等Iterable变成Iterator可以使用iter()函数：
+
----
>>> isinstance(iter([]), Iterator)
True
>>> isinstance(iter('abc'), Iterator)
True
----

. 函数式编程

.. 高阶函数

... map/reduce

.... map()函数接收两个参数，一个是函数，一个是Iterable。
map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
+
函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：
+
----
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
----
+
----
>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
----

.... reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，
reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
+
----
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
----
+
例如对一个序列求和：
+
----
>>> from functools import reduce
>>> def add(x, y):
...     return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25
----
+
把序列[1, 3, 5, 7, 9]变换成整数13579：
+
----
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
----
+
配合map()，我们就可以写出把str转换为int的函数：
+
----
from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
----

... filter
+
filter()也接收一个函数和一个序列，把传入的函数依次作用于每个元素，
然后根据返回值是True还是False决定保留还是丢弃该元素。
+
用埃氏筛法计算素数的方法举例：
+
----
#  构造一个从3开始的奇数序列
def _odd_iter():
    n = 1
    while True:
        n += 2
        yield n

#  筛选函数
def _not_divisible(n):
    return lambda x: x % n > 0

#  定义一个生成器，不断返回下一个素数
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列

# 打印1000以内的素数:
for n in primes():
    if n < 1000:
        print(n)
    else:
        break
----

... sorted
+
sorted()函数可以对list进行排序，还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
+
----
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
----
+
忽略大小写的排序：
+
----
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
----
+
要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
+
----
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
----

.. 返回函数

... 函数作为返回值
+
----
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
----
+
函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，
当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，
这种称为“闭包（Closure）”的程序结构拥有极大的威力。
+
当调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：
+
----
>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f1==f2
False
----

... 闭包
+
返回的函数并没有立刻执行，而是直到调用了f()才执行：
+
----
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()

>>> f1()
9
>>> f2()
9
>>> f3()
9
----
+
返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
+
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，
无论该循环变量后续如何更改，已绑定到函数参数的值不变：
+
----
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs

>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9
----

.. 匿名函数
+
关键字lambda表示匿名函数，冒号前面的x表示函数参数。
+
----
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
----
+
匿名函数lambda x: x * x实际上就是：
+
----
def f(x):
    return x * x
----
+
匿名函数只能有一个表达式，不用写return，返回值就是该表达式的结果。

.. 装饰器
+
在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

... 一个完整的decorator的写法如下：
+
----
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
----

... 针对带参数的decorator：
+
----
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
----

.. 偏函数

... Python的偏函数（Partial function）和数学意义上的偏函数不一样。

... functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，
可以直接使用下面的代码创建一个新的函数int2：
+
----
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85
----
+
functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），
返回一个新的函数，调用这个新函数会更简单。
+
仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：
+
----
>>> int2('1000000', base=10)
1000000
----

... 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：
+
----
max2 = functools.partial(max, 10)
----
+
实际上会把10作为*args的一部分自动加到左边，也就是：
+
----
max2(5, 6, 7)
----
+
相当于：
+
----
args = (10, 5, 6, 7)
max(*args)
----
+
结果为10。

. 模块

.. 每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，
Python就把这个目录当成普通目录，而不是一个包。

.. __init__.py可以是空文件，也可以有Python代码。

.. 作用域
+
有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。

.. 所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：
+
----
>>> import sys
>>> sys.path
----

.. 要添加自己的搜索目录，有两种方法：

... 一是直接修改sys.path，添加要搜索的目录：
+
----
>>> import sys
>>> sys.path.append('/Users/michael/my_py_scripts')
----
+
这种方法是在运行时修改，运行结束后失效。

... 第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。
注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。

. 面向对象编程

.. 类和实例
+
----
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
----
+
... class后面紧接着是类名，即Student，类名通常是大写开头的单词
... 紧接着是(object)，表示该类是从哪个类继承下来的
... 如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。


.. 访问限制



.. 继承和多态



.. 获取对象信息



.. 实例属性和类属性



. 面向对象高级编程
+
（略）



. 错误、调试和测试



. IO编程



. 进程和线程




. 正则表达式



. 常用内建模块



. 常用第三方模块



. 图形界面



. 网络编程



. 电子邮件

.. SMTP发送邮件
+
示例代码：
+
----
# coding=UTF-8


from email import encoders
from email.header import Header
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr

import smtplib

def _format_addr(s):
    name, addr = parseaddr(s)
    return formataddr((Header(name, 'utf-8').encode(), addr))

from_addr = input('From: ')
password = input('Password: ')
to_addr = input('To: ')
smtp_server = input('SMTP server: ')

# 邮件对象:
msg = MIMEMultipart()
msg['From'] = _format_addr('Python爱好者 <%s>' % from_addr)
msg['To'] = _format_addr('管理员 <%s>' % to_addr)
msg['Subject'] = Header('来自SMTP的问候……', 'utf-8').encode()

# 邮件正文是MIMEText:
# msg.attach(MIMEText('send with file...', 'plain', 'utf-8'))
msg.attach(MIMEText('<html><body><h1>Hello</h1>' +
    '<p><img src="cid:0"></p>' +
    '</body></html>', 'html', 'utf-8'))

# 添加附件就是加上一个MIMEBase，从本地读取一个图片:
with open(r'C:\png-0002.jpg', 'rb') as f:
    # 设置附件的MIME和文件名，这里是png类型:
    mime = MIMEBase('image', 'png', filename='test.png')
    # 加上必要的头信息:
    mime.add_header('Content-Disposition', 'attachment', filename='test.png')
    mime.add_header('Content-ID', '<0>')
    mime.add_header('X-Attachment-Id', '0')
    # 把附件的内容读进来:
    mime.set_payload(f.read())
    # 用Base64编码:
    encoders.encode_base64(mime)
    # 添加到MIMEMultipart:
    msg.attach(mime)

server = smtplib.SMTP(smtp_server, 25)
server.set_debuglevel(1)
# server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()

----
+
邮件对象的嵌套关系如下：
+
----
Message
+- MIMEBase
   +- MIMEMultipart
   +- MIMENonMultipart
      +- MIMEMessage
      +- MIMEText
      +- MIMEImage
----


.. POP3收取邮件



. 访问数据库

.. sqlite
+
Python内置了SQLite3。cursor示例：
+
----
cursor.execute('select * from user where name=? and pwd=?', ('abc', 'password'))
----
+
要确保打开的Connection对象和Cursor对象都正确地被关闭，否则，资源就会泄露。

.. ORM框架SQLAlchemy

. Web开发



. 异步IO





