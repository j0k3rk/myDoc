= JavaScript
:icons:
:toc:
:toclevels: 4
:numbered:

== 基础

=== JavaScript 元素

==== <Script>

. 属性

.. async 可选

.. charset 可选

.. defer 可选
+
立即下载、延迟执行，此属性的用途是表明脚本在执行时不会影响页面的构造。

.. language 已废弃
.. src 可选

.. type 可选
+
已不推荐使用，但考虑到约定俗成和最大限度的浏览器兼容性，可以设为 text/javascript（默认值）。

. 在使用 <script> 嵌入 JavaScript 代码时，不要在代码中的任何地方出现"</script>"字符串。
+
[source, html, numbered]
----
<script type="text/javascript">
    function sayScript(){
        alert("</script>");     //错误
        alert("<\/script>");    //正确
    }
</script>
----

. 如果是在 XHTML 文档中，可以省略 </script> 标签，例如：
+
[source, html, numbered]
----
<script type="text/javascript" src="example.js" />
----
+
但是，不能在 HTML 文档使用这种语法。原因是这种语法不符合 HTML 规范，而且也得不到某些浏览器（尤其是IE）的正确解析。
+
[NOTE]
======
- 按惯例，外部 JavaScript 文件带有 .js 扩展名，但这个扩展名不是必需的。
- 如果不使用 .js 扩展名，请确保服务器能返回正确的 MIME 类型。
======

. 带有 src 属性的 <script> 元素不应再包含额外代码。如果包含了，嵌入代码会被忽略，只有外部脚本文件会被下载并执行。

. 只要不存在 defer 和 async 属性，浏览器都会按照<script>元素在页面中出现的先后顺序对它们依次进行解析。换句话说，
  在第一个 <script> 元素包含的代码解析完成后，第二个 <script> 包含的代码才会被解析，然后才是第三个、第四个……

. 按照传统做法，所有 <script> 元素都应该放在页面的 <head> 元素中。
  这种做法的目的就是把所有外部文件（包括 CSS 文件和 JavaScript 文件）的引用都放在相同的地方。
  对于那些需要很多 JavaScript 代码的页面来说，这会导致浏览器在呈现页面时出现明显的延迟（浏览器在遇到 <body> 标签时才开始呈现内容）。
  为了避免这个问题，现代 Web 应用程序一般都把全部 JavaScript 引用放在 <body> 元素中页面内容的后面：
+
[source, html, numbered]
----
<!DOCTYPE html>
<html>
<head>
    <title>Example HTML Page</title>
</head>
<body>
<!-- 这里放内容 -->
<script type="text/javascript" src="example1.js"></script>
<script type="text/javascript" src="example2.js"></script>
</body>
</html>
----

. 延迟脚本
+
[source, html, numbered]
----
<!DOCTYPE html>
<html>
<head>
    <title>Example HTML Page</title>
    <script type="text/javascript" defer="defer" src="example1.js"></script>
    <script type="text/javascript" defer="defer" src="example2.js"></script>
</head>
<body>
<!-- 这里放内容 -->
</body>
</html>
----

.. HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个执行，而这两个脚本会先于 DOMContentLoaded 事件执行。
.. 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。
.. defer 属性只适用于外部脚本文件。这一点在 HTML5 中已经明确规定，因此支持 HTML5 的实现会忽略给嵌入脚本设置的 defer 属性。
   IE4～IE7 还支持对嵌入脚本的 defer 属性，但 IE8 及之后版本则完全支持 HTML5 规定的行为。

. 异步脚本
+
[source, html, numbered]
----
<!DOCTYPE html>
<html>
<head>
    <title>Example HTML Page</title>
    <script type="text/javascript" async src="example1.js"></script>
    <script type="text/javascript" async src="example2.js"></script>
</head>
<body>
<!-- 这里放内容 -->
</body>
</html>
----

.. 与defer 类似，async 只适用于外部脚本文件，并立即下载文件。但与defer不同，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。
.. 确保两脚本之间互不依赖非常重要。
.. 指定 async 属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。
.. 异步脚本一定会在页面的 load 事件前执行，但可能会在DOMContentLoaded 事件触发之前或之后执行。

. 文档模式
.. 混杂模式（quirks mode）

.. 标准模式（standards mode）
+
[source, html, numbered]
----
<!-- HTML 4.01 严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<!-- XHTML 1.0 严格型 -->
<!DOCTYPE html PUBLIC
        "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- HTML 5 -->
<!DOCTYPE html>
----

.. 准标准模式（almost standards mode）
+
准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计。
+
[source, html, numbered]
----
<!-- HTML 4.01 过渡型 -->
<!DOCTYPE HTML PUBLIC
        "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">

<!-- HTML 4.01 框架集型 -->
<!DOCTYPE HTML PUBLIC
        "-//W3C//DTD HTML 4.01 Frameset//EN"
        "http://www.w3.org/TR/html4/frameset.dtd">

<!-- XHTML 1.0 过渡型 -->
<!DOCTYPE html PUBLIC
        "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- XHTML 1.0 框架集型 -->
<!DOCTYPE html PUBLIC
        "-//W3C//DTD XHTML 1.0 Frameset//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
----

==== <NoScript>

. 举例
+
[source, html, numbered]
----
<html>
<head>
    <title>Example HTML Page</title>
    <script type="text/javascript" defer="defer" src="example1.js"></script>
    <script type="text/javascript" defer="defer" src="example2.js"></script>
</head>
<body>
<noscript>
    <p>本页面需要浏览器支持（启用）JavaScript。
</noscript>
</body>
</html>
----

=== 关键字和保留字

. ECMA-262 全部关键字（第5版新增的以*号标出）
+
[source, ecmascript, numbered]
----
break     do       instanceof typeof
case      else     new        var
catch     finally  return     void
continue  for      switch     while
debugger* function this       with
default   if       throw
delete    in       try
----

. ECMA-262 第3版全部保留字
+
[source, ecmascript, numbered]
----
abstract enum       int       short
boolean  export     interface static
byte     extends    long      super
char     final      native    synchronized
class    float      package   throws
const    goto       private   transient
debugger implements protected volatile
double   import     public
----

. ECMA-262 第5版，【非】严格模式保留字
+
[source, ecmascript, numbered]
----
class enum   extends super
const export import
----
+
严格模式还有以下保留字
+
[source, ecmascript, numbered]
----
implements package   public
interface  private   static
let*       protected yield*
----
+
另外还有以下受到限制，严格模式下，不能作为标识符或属性名
+
[source, ecmascript, numbered]
----
arguments eval
----

=== 变量

. 用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。
. 省略 var 操作符的，就成了全局变量。（但不推荐，严格模式下将报错。）

=== 数据类型

ECMAScript 中有5种简单（/基本）数据类型：Undefined、Null、Boolean、Number和String，1种复杂数据类型：Object。

. typeof 是一个操作符而不是函数，返回值：undefined, boolean, string, number, object, function
+
[source, javascript, numbered]
----
alert(typeof(null));    //object
----

. Undefined 类型
+
[source, javascript, numbered]
----
var message;
alert(message == undefined);    //true
----
+
未初始化的变量（默认值为"undefined"）和初始化为"undefined"的变量还是略有区别：
+
[source, javascript, numbered]
----
var message;    //变量声明后默认取得 undefined 值
alert(message); //undefined
alert(age);     //产生错误
----

. Null 类型
+
[source, javascript, numbered]
----
alert(null == null);    //true

// undefined 值派生自 null 值，因此 ECMA-262 规定对它们的相等性测试要返回true
alert(null == undefined);   //true
----

. Boolean 类型

.. Boolean 类型的字面值 true 和 false 区分大小写，True 和 False 都不是 Boolean 值，只是标识符。

.. Boolean()转型函数：
+
[cols="<10,<20,<20", options="header"]
|====
|数据类型 |转换为true的值 |转换为false的值
|Boolean |true |false
|String |任何非空字符串 |""（空字符串）
|Number |任何非零数字值（包括无穷大） |0和NaN
|Object |任何对象 |null
|Undefined |n/a（not applicable） |undefined
|====

. Number 类型

.. 八进制数值
+
第一位必须是零（0），在严格模式下无效：
+
[source, javascript, numbered]
----
var octalNum1 = 070;    // 八进制的56
var octalNum2 = 079;    // 无效的八进制数值——解析为79
----

.. 十六进制数值
+
前两位必须是0x，字母 A～F 可以大写，也可以小写

.. 进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。
+
[NOTE]
====
JavaScript 中，可以保存正零（+0）和负零（-0），正零和负零被认为相等。
====

.. 浮点数值

... 基本写法：
+
[source, javascript, numbered]
----
var floatNum2 = 0.1;
var floatNum3 = .1;     //有效，但不推荐
----

... ECMAScript 会不失时机地将浮点数值转换为整数值：
+
[source, javascript, numbered]
----
var floatNum1 = 1.;     //小数点后面没有数字——解析为1
var floatNum2 = 10.0;   //整数——解析为10
----

... 默认情况下，ECMASctipt 会将小数点后面带有6个零及以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e-7）。

... 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是0.30000000000000004。
    这个小小的舍入误差会导致无法测试特定的浮点数值。
+
[source, javascript, numbered]
----
var a = 0.1;
var b = 0.2;
if (a + b == 0.3) { //不要做这样的测试！
  alert('You got 0.3.');
}
----
+
[NOTE]
====
关于浮点数值计算会产生舍入误差的问题，这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；
其他使用相同数值格式的语言也存在这个问题。
====

.. 数值范围

... ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中，最大数值保存在 Number.MAX_VALUE 中。

... 如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。
    负数为 -Infinity（负无穷），正数为 Infinity（正无穷）。该值将无法继续参与下一次的计算。可以使用 isFinite() 函数进行检测。

.. NaN

... NaN，即非数值（Not a Number）是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况。例如 0 除以 0 将返回 NaN 。

... 任何涉及 NaN 的操作（例如 NaN/10）都会返回NaN。

... NaN 与任何值都不相等，包括 NaN 本身。
+
[source, javascript, numbered]
----
alert(NaN == NaN);      //false
----

... isNaN()
+
[source, javascript, numbered]
----
alert(isNaN(NaN));  //true
alert(isNaN(10));   //false（10 是一个数值）
alert(isNaN("10")); //false（可以被转换成数值10）
alert(isNaN("blue"));   //true（不能转换成数值）
alert(isNaN(true)); //false（可以被转换成数值1）
----
+
[NOTE]
====
- isNaN() 也适用于对象，在基于对象调用isNaN() 函数时，会首先调用对象的 valueOf()方法，然后确定该方法返回的值是否可以转换为数值。
- 如果不能，则基于这个返回值再调用 toString() 方法，再测试返回值。
====

.. 数值转换
+
有3个函数可以把非数值转换为数值：Number()、parseInt() 和 parseFloat()。

... Number()
+
[source, javascript, numbered]
----
var num1 = Number("Hello world!");  //NaN
var num2 = Number("");  //0
var num3 = Number("000011");    //11
var num4 = Number(true);    //1
----

.... true 和 false 将分别被转换为 1 和 0。

.... null 值返回 0。

.... undefined 值返回 NaN。

.... 字符串遵循以下规则：
..... 字符串中只包含数字（包括带正号或负号的情况），则将其转换为十进制数值（忽略前导0）。
..... 字符串中包含有效的浮点格式，则将其转换为对应的浮点数值（忽略前导0）。
..... 字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值。
..... 字符串是空的（不包含任何字符），则将其转换为0。
..... 字符串中包含除上述格式之外的字符，则将其转换为 NaN。

.... 如果是对象，则调用对象的 valueOf() 方法，然后进行转换。
     如果转换的结果是 NaN ，则调用对象的 toString() 方法，然后再次转换。

... parseInt()
+
[source, javascript, numbered]
----
var num1 = parseInt("1234blue");    //1234
var num2 = parseInt("");    //NaN
var num3 = parseInt("0xA"); //10
var num4 = parseInt(22.5);  //22
var num5 = parseInt("70");  //70
var num6 = parseInt("070"); //ECMAScript 3 是56，ECMAScript 5 是70
----
+
为了消除 ECMAScript 3 和 5 的分歧，可以提供第2个参数：
+
[source, javascript, numbered]
----
var num1 = parseInt("0xAF", 16); //175
var num2 = parseInt("AF", 16);  //175
var num3 = parseInt("AF");      //NaN

var num4 = parseInt("10", 2);   //2 （按二进制解析）
var num5 = parseInt("10", 8);   //8 （按八进制解析）
var num6 = parseInt("10", 10);  //10 （按十进制解析）
var num7 = parseInt("10", 16);  //16 （按十六进制解析）
----

... parseFloat()
+
[source, javascript, numbered]
----
var num1 = parseFloat("1234blue");  //1234（整数）
var num2 = parseFloat("0xA");       //0
var num3 = parseFloat("22.5");      //22.5
var num4 = parseFloat("22.34.5");   //22.34
var num5 = parseFloat("0908.5");    //908.5
var num6 = parseFloat("3.125e7");   //31250000
----

.... 只解析十进制值，没有用第二个参数指定基数的用法。十六进制格式的字符串始终会被转换成0。
.... 如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。

. String 类型

.. 字符字面量
+
[cols="<5,<35", options="header"]
|====
|字面量 |含义
|\n |换行
|\t |制表
|\b |空格
|\r |回车
|\f |进纸
|\\ |斜杠
|\' |单引号（'），在用单引号表示的字符串中使用。例如：'He said, \'hey.\''
|\" |双引号（"），在用双引号表示的字符串中使用。例如："He said, \"hey.\""
|\xnn |以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示"A"
|\unnnn |以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ
|====

.. 任何字符串的长度都可以通过访问其 length 属性取得，如果字符串中包含双字节字符，那么 length 属性可能不会精确地返回字符串中的字符数目。

.. ECMAScript 中的字符串一旦创建，它们的值就不能被改变。

.. 除了 null 和 undefined 值外，数值、布尔值、对象和字符串值都有 toString() 方法。
   多数情况下，调用toString()方法不必传递参数。但是，可以传递一个参数来指定输出数值的基数。
+
[source, javascript, numbered]
----
var num = 10;
alert(num.toString());      //"10"
alert(num.toString(2));     //"1010"
alert(num.toString(8));     //"12"
alert(num.toString(10));    //"10"
alert(num.toString(16));    //"a"
----

.. String()

... 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果；
... 如果值是 null，则返回"null"；
... 如果值是 undefined，则返回"undefined"。

. Object 类型

== jQuery

=== 基础

==== 根据类型、类或id选择元素

[source, javascript, numbered]
----
$('*')         //选择文档中的所有元素
$('.myclass')  //选择所有已向其分配CSS类myclass的元素
$('element')   //选择所有类型为element的元素
$('#myid')     //选择id为myid的元素
----

==== 根据关系和联合选择元素

[source, javascript, numbered]
----
$('tr td')         //匹配所有作为tr元素的后代的td元素
$('tr > td')       //匹配所有作为tr元素的直接后代的td元素
$('h2 + table')    //匹配紧接在h2元素后面的table元素
$('h2 ~ table')    //匹配h2元素后面的table元素（不一定紧邻h2元素）
$('tr, td')        //匹配tr和td元素
----

==== 特性选择器

[source, javascript, numbered]
----
$('[attr]')         //选择具有attr特性的元素，不论其特性值如何
$('[attr]="val"')   //选择具有attr特性且其值为val的元素
$('[attr]!="val"')  //选择具有attr特性且其值不为val的元素
$('[attr]^="val"')  //选择具有attr特性且其值以val开头的元素
$('[attr]~="val"')  //选择具有attr特性且其值包含val的元素
$('[attr]$="val"')  //选择具有attr特性且其值以val结尾的元素
$('[attr]|="val"')  //选择具有attr特性且其值为val或以val后连接字符（val-）开头的元素
----

==== 基本过滤器

[source, javascript, numbered]
----
:eq(n)          //使用以零为基准的索引选择第n个元素
:even:odd       //选择编号为偶数或奇数的元素
:first:last     //选择第一个或最后一个元素
:gt(n):lt(n)    //选择其索引相对于其同级大于或小于n的所有元素
:header         //选择所有属于标题（h1、h2等）的元素
:not(selector)  //选择所有与选择器不匹配的元素
----

==== 内容过滤器

[source, javascript, numbered]
----
:contains('text')   //选择包含text或其子元素包含text的元素
:has('selector')    //选择至少有一个子元素与selector匹配的元素
:empty              //选择没有子元素的元素
:parent             //选择至少有一个其他元素的元素
:first-child        //选择作为其父元素的第一个子元素的元素
:last-child         //选择作为其父元素的最后一个子元素的元素
:nth-child(n)       //使用以1为起始的索引，选择作为其父元素的第n个子元素的元素
:only-child         //选择作为其父元素的唯一子元素的元素
----

==== 表单过滤器

[source, javascript, numbered]
----
:button             //选择类型为button的button元素和input元素
:checkbox           //选择复选框
:checked            //选择处于选中状态的复选框和单选按钮
:disabled:enabled   //分别选择已启用或已禁用的元素
:input              //选择input元素
:password           //选择password元素
:radio              //选择单选按钮
:reset              //选择类型为reset的input元素
:selected           //选择处于选中状态的option元素
:submit             //选择类型为submit的input元素
:text               //选择类型为text的input元素
----

==== CSS函数

[source, javascript, numbered]
----
addClass('myClass')         //将指定的类名添加到所选元素的class特性中
hasClass('myClass')         //如果已将指定类分配给所选的元素，则返回true
removeClass('myClass')      //从所选元素的class特性中删除指定的类名
toggleClass('myClass')      //如果指定的类不存在，则添加该类，否则删除该类
css('property', 'value')    //将指定的属性和值添加到所选元素的样式特性中
css('property')             //从第一个匹配的元素返回特定属性的值
----

==== DOM导航函数

[source, javascript, numbered]
----
children()          //获取所选元素的子元素
closest('selector') //遍历所选的每个元素的祖先元素，查找与指定选择器匹配的第一个元素实例
filter('selector')  //将所选元素缩减到那些与指定选择器匹配的元素
first('selector')   //遍历所选元素的后代，查找所有与指定选择器匹配的元素
next()              //获取紧接在所选元素之后的同级元素
prev()              //获取紧靠在所选元素之前的同级元素
parent()            //返回所选元素的直接父元素
sibilings()         //返回所选元素的同级元素
----

==== DOM操作函数

[source, javascript, numbered]
----
before('new') after('new')   //将new元素插入到所选元素之前或之后
insertBefore() insertAfter() //用法类似before和after，但颠倒新元素和选择器的顺序，返回新建的元素
prepend('new') append('new') //将new元素插入到所选元素中，作为第一个或最后一个子元素
prependTo() appendTo()       //用法与prepend和append相同，但颠倒新元素和选择器的顺序，返回新建的元素
empty()                      //删除所选元素的所有子元素
remove()                     //删除DOM中的所选元素
attr('name', 'val')          //将所选元素的name特性设置为val，如果特性不存在，则创建特性
removeAttr('name')           //从所选元素中删除name特性
----

==== 事件处理函数

[source, javascript, numbered]
----
click       //单击鼠标时触发
dblclick    //双击鼠标时触发
mouseenter  //鼠标进入元素所在的屏幕区域时触发
mouseleave  //鼠标离开元素所在的屏幕区域时触发
change      //元素值发生更改时触发
select      //选择元素值时触发
submit      //提交表单时触发
----
