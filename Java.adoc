=== Servlet & JSP 基础

==== （一）请求、响应、会话等

. 只有 请求属性 和 局部变量 是线程安全的。

. RequestDispatcher

.. 两种获得方法
+
----
//1.从ServletRequest获得
RequestDispatcher view = request.getRequestDispatcher("result.jsp");

//2.从ServletContext获得，不能指定相对路径，路径必须以【斜线】开头
RequestDispatcher view = getServletContext().getRequestDispatcher("/result.jsp");
----

.. 只有2个方法
+
----
//常用，转发请求
forward()

//不常用，转发请求，处理完后再返回发送者
include()
----

. 如果已经提交了响应，就不能再转发请求。

. 会话关联URL要点

.. 在写至响应的HTML中，URL重写把会话ID增加到其中所有URL的最后。
.. 会话ID作为请求URL最后的“额外”信息再通过请求返回。
.. 如果客户不接受cookie，URL重写会自动发生，但是必须显式地对所有URL编码。
.. 要对一个URL编码，需要调用response.encodeURL(aString)。
.. 没有办法对静态页面完成自动的URL重写，所以，如果依赖于会话，就必须使用动态生成的页面。

. 会话有3种死法：

.. 超时
.. 在会话对象上调用invalidate()。
.. 应用结束（崩溃或取消部署）。

. 设置会话超时

.. 在DD（deployment descriptor）中配置会话超时
+
----
<web-app ...>
    <servlet>
    ...
    </servlet>
    <session-config>
        <!-- 以分钟为单位 -->
        <session-timeout>15</session-timeout>
    </session-config>
</web-app>
----

.. 设定一个特定会话的会话超时
+
----
//以秒为单位，设为0时表示立即超时
session.setMaxInactiveInterval(20*60);
----

. 设置cookie在客户端上的存活时间
+
----
//以秒为单位。若设为-1，浏览器退出时cookie即消失。
cookie.setMaxAge(30*60);
----

. 从客户请求得到cookie（或多个cookie）
+
----
//没有getCookie(String)方法，只能得到一个数组，然后循环处理。
Cookie[] cookies = request.getCookies();
if ( cookies != null ) {
    for (int i = 0; i < cookies.length; i++) {
        Cookie cookie = cookies[i];
        if (cookie.getName().equals("username")) {
            String userName = cookie.getValue();
            out.println("Hello " + userName);
            break;
        }
    }
}
----

. Cookie和首部的区别

.. 向响应增加一个首部时，名和值String作为参数传入。
+
----
response.addHeader("foo", "bar");
----

.. 向响应增加一个Cookie时，要传递一个Cookie对象。
+
----
Cookie cookie = new Cookie("name", name);
response.addCookie(cookie);
----

.. 首部既有setHeader()方法，又有addHeader()方法，替换现有值或增加一个值。

.. 不存在setCookie()方法，只有addCookie()方法。

. 监听者类型
+
|===
|里程碑 |事件和监听者类型
|生命周期 - 创建/撤销 会话 |HttpSessionEvent HttpSessionListener
|属性 - 增加/删除/替换 属性 |HttpSessionBindingEvent HttpSessionAttributeListener
|迁移 - 会话准备钝化/会话已经激活 |HttpSessionEvent HttpSessionActivationListener
|===
+
上述3个监听者必须在DD中注册，但HttpSessionBindingListener不在DD中配置。

. 只有HttpSession对象（及其属性）会从一个VM移到另一个VM。

.. 每个VM中有一个ServletContext。
.. 每个VM上的每个Servlet都有一个ServletConfig。
.. 对于每个Web应用的一个给定的会话ID，只有一个HttpSession对象，而不论应用分布在多少个VM上。

. 与会话有关的监听者
+
|===
|场景 |监听者接口/方法 |事件类型

|有多少个并发用户（活动的会话）
|HttpSessionListener(javax.servlet.http) sessionCreated sessionDestroyed
|HttpSessionEvent

|会话何时从一个VM移到另一个VM
|HttpSessionActivationListener(javax.servlet.http) sessionDidActivate sessionWillPassivate
|HttpSessionEvent(注意:没有特定的HttpSessionActivationEvent)

|有一个属性类(对象作为一个属性值)，此类对象绑定到会话或从会话删除时得到通知
|HttpSessionBindingListener(javax.servlet.http) valueBound valueUnbound
|HttpSessionBindingEvent

|会话什么时候增加、删除或替换会话属性
|HttpSessionAttributeListener(javax.servlet.http) attributeAdded attributeRemoved attributeReplaced
|HttpSessionBindingEvent(注意:没有特定的HttpSessionAttributeEvent)
|===

==== (二)JSP基本用法

. JSP隐式对象
+
|===
|API |隐式对象
|JspWriter |out
|HttpServletRequest |request
|HttpServletResponse |response
|HttpSession |session
|ServletConfig |config
|Throwable |exception
|PageContext |pageContext
|Object |page
|===
+
JspWriter与从HttpServletResponse得到的PrintWriter类似，增加了一些缓冲功能。

. JSP中的两种注释
+
----
<!-- HTML注释 -->
<%-- JSP注释 --%>
----

. 容器根据JSP生成一个类，这个类实现了HttpJspPage接口，有3个关键方法：

.. jspInit()，可以覆盖
.. jspDestroy()，可以覆盖
.. _jspService()，不能覆盖

. 属性设置：servlet VS JSP
+
|===
| |servlet |JSP(隐式对象)

|应用
|getServletContext().setAttribute(“foo”, barObj);
|application.setAttribute(“foo”, barObj);

|请求
|request.setAttribute(“foo”, barObj);
|request.setAttribute(“foo”, barObj);

|会话
|request.getSession().setAttribute(“foo”, barObj);
|session.setAttribute(“foo”, barObj);

|页面
|不适用！
|pageContext.setAttribute(“foo”, barObj);
|===
+
注意“ServletContext”这个容易误导的命名，没有“上下文”、只有“应用”。

. pageContext 获取/设置 属性示例
+
----
<%-- pageContext对应页面作用域，有两个重载的getAttribute()，
一个String参数的为默认，String+int 参数的可以取其他作用域的属性。 --%>

<%-- 设置一个页面作用域属性 --%>
<% Float one = new Float(42.5); %>
<% pageContext.setAttribute("foo", one); %>

<%-- 获得一个页面作用域属性 --%>
<%= pageContext.getAttribute("foo") %>

<%-- 设置一个会话作用域属性 --%>
<% Float two = new Float(22.4); %>
<% pageContext.setAttribute("foo", two, PageContext.SESSION_SCOPE); %>

<%-- 获得一个会话作用域属性 --%>
<%= pageContext.getAttribute("foo", PageContext.SESSION_SCOPE) %>
<%-- 等价于 --%>
<%= session.getAttribute("foo") %>

<%-- 获得一个应用作用域属性 --%>
<%= pageContext.getAttribute("mail", pageContext.APPLICATION_SCOPE) %>
<%-- 等价于 --%>
<%= application.getAttribute("mail") %>

<%-- 不知道作用域，也可以查找属性。
查找顺序：页面作用域->请求作用域->会话作用域->应用作用域。
在一个作用域中找到即不再继续。 --%>
<%= pageContext.findAttribute("foo") %>
----

. JSP指令

.. page

... import 属性
.... java.lang、javax.servlet、javax.servlet.http、javax.servlet.jsp 将自动默认添加。

... isThreadSafe 属性
... contentType 属性
... isELIgnored 属性
... isErrorPage 属性
... errorPage 属性
... language 属性
... extends 属性
... session 属性
... buffer 属性
... autoFlush 属性
... info 属性
... pageEncoding 属性

.. taglib
.. include

. 在DD中使用 <scripting-invalid> 禁用脚本元素
+
----
<web-app ...>
    ...
    <jsp-config>
        <jsp-property-group>
        <url-pattern>*.jsp</url-pattern>
        <scripting-invalid>
            true
        </scripting-invalid>
        </jsp-property-group>
    </jsp-config>
    ...
</web-app>
----
+
注意，JSP规范中已经 删除 了如下指令属性：
+
----
<%@ page isScriptingEnabled="false" %>
----

. EL默认启用，如果需要忽略EL，可以在DD中使用<el-ignored> 或者在JSP中使用 isELIgnored page指令属性。
+
----
<web-app ...>
    ...
    <jsp-config>
        <jsp-property-group>
        <url-pattern>*.jsp</url-pattern>
        <el-ignored>
            true
        </el-ignored>
        </jsp-property-group>
    </jsp-config>
    ...
</web-app>
----
+
----
<%@ page isELIgnored="true" %>
----
+
注意：如果以上两者冲突，page指令优先于DD设置。


==== (三)无脚本的JSP

. JavaBean标准动作
+
----
<jsp:useBean>
<jsp:getProperty>
<jsp:setProperty>
----

. JavaBean 和 EnterpriseJavaBean（EJB）不同，使用规则如下：

.. 必须有一个无参数的公共构造函数。

.. 必须按命名约定来命名公共的获取方法和设置方法：
... 首先是 get 和 set ，如果是布尔类property，获取方法的前缀为 is。后面跟同一个词，例如：getFoo(), setFoo()
... 要得到property名，先去掉 get 和 set，再把余下部分的第一个字母变成小写。

.. 设置方法的参数类型和获取方法的返回类型必须一样。
.. property名和类型是由获取方法和设置方法得出，而不是得自于类中的一个成员。
.. 结合JSP使用时，property类型必须是String，或者是一个基本类型。

. <jsp:useBean>

.. <jsp:useBean>体中的代码会有条件的运行，只有找不到bean而且创建一个新bean时才会运行。
+
----
<jsp:useBean id="person" class="foo.Person" scope="page" >
         <jsp:setProperty name="person" property="name" value="Fred" />
</jsp:useBean >
----

.. type==引用类型（可以是抽象类），class==对象类型（必须是具体类）。
+
----
type x = new class()
----

.. 如果使用了type，但没有class，bean必须已经存在。

.. 如果使用了class（有或没有type），class不能是抽象类，而且必须有一个无参数的公共构造函数。

.. scope属性默认为“page”

.. 利用param属性，可以把bean的property value设置为一个请求参数的值。只需指定请求参数。

.. 如果请求参数名与bean的property name匹配，就不需要在<jsp:setProperty>标记中为该property指定值。

.. 如果所有请求参数名都与bean的property name匹配，可以按如下处理（设为*号）：
+
----
<jsp:useBean id="person" type="foo.Person" class="foo.Employee">
         <jsp:setProperty name="person" property="*">
</jsp:useBean>
----

.. Bean标记会自动转换String或基本类型的property。

.. 如果使用脚本，就不会自动完成String到基本类型的转换。即使表达式在<jsp:setProperty>标记中也会失败。

.. 利用<jsp:getProperty>只能访问bean属性的property，不能访问嵌套的property。
（例如property不是String或基本类型，而是Object类型。）可以使用表达式语言（EL）解决问题，例如：
+
----
<html><body>
         Dog's name is: ${person.dog.name}
</body></html>
----

. EL隐式对象

.. pageScope

.. requestScope
... requestScope不是请求对象，只是请求作用域属性的一个Map。可以使用 ${pageContext.request.method}来得到请求对象的方法。

.. sessionScope

.. applicationScope

.. param

.. paramValues

.. header

.. headerValues

.. cookie

.. initParam
... servlet初始化参数由<init-param>配置，上下文参数由<context-param>配置。EL中隐式对象 initParam 对应的是 上下文参数。

.. pageContext
... 唯一不是映射的对象，是pageContext对象的实际引用，是一个JavaBean。

. EL操作符和保留字

.. 最常用的是点号(.)和中括号([])，以下两行代码等价：
+
----
<%-- bean和Map可使用点号(.) --%>

${person.name}

<%-- bean、Map、List、数组等都可以使用[]。
     中括号左边是一个List或数组时，且索引是一个String直接量，则索引会自动强制转换为int。
     如果中括号里没有引号（不是String直接量），容器就会计算其中的内容。
     在中括号里可以使用嵌套表达式，深度不限。
--%>

${person["name"]}
----

.. 算术操作符（5个）

... 加法：+
... 减法：-
... 乘法：*
... 除法：/ 和 div （可以除0，得 Infinity）
... 取模：% 和 mod

.. 逻辑操作符（3个）

... 与：&& 和 and
... 或：|| 和 or
... 非：! 和 not

.. 关系操作符（6个）

... 等于：== 和 eq
... 不等于：!= 和 ne
... 小于：< 和 lt
... 大于：> 和 gt
... 小于等于：<= 和 le
... 大于等于：>= 和 ge

.. 保留字

... true/false
... null
... instanceof
... empty

+
要在JSP中使用函数，必须使用 taglib 指令声明一个命名空间。在 taglib 指令中放一个 prefix 属性，
告诉容器你要调用的函数在哪个TLD里能找到。例如：
+
----
<%@ taglib prefix="mine" uri="/WEB-INF/foo.tld" %>
----

. EL函数可以有参数，但TLD中要为每个参数指定完全限定名（除非是一个基本类型）。
+
例如，如果函数取一个Map参数，则应当是：
+
----
<function-signature>
         int rollDice(java.util.Map)
</function-signature>
----

. EL能妥善处理null值，即使找不到表达式中指定名的属性/性质/键，也能正常显示页面。

.. 算术表达式中，EL把null值看作“0”。
.. 逻辑表达式中，EL把null值看作“false”。

. 可重用的模板部件

.. include 指令，在转换时插入”Header.jsp”的源代码。
+
----
...
<%@ include file="Header.jsp" %>
...
----

.. <jsp:include>标准动作，在运行时插入“Header.jsp”的响应。
+
----
...
<jsp:include page="Header.jsp" />
...
----

.. 备注：
... <jsp:include>标准动作会带来额外的性能开销，但总能保证有最新内容。
... 使用include指令时，Tomcat也可以自动检测到所包含文件发生了变化。问题是，规范并不保证这一点，如果代码全依赖于此，应用就不一定能够顺利移植到其他容器。
... 两者都是位置敏感的。
... 虽然include指令是静态的，但是如果所包含的东西是动态的，每次访问页面时，所包含的东西会动态运行。
... 全部源代码都会粘贴，不要把开始和结束HTML、BODY标记放在可重用部件中。

. 使用<jsp:param>定制包含的内容

.. 笨方法：把定制内容放在主页面上。

.. 好方法：把定制内容作为请求参数传递给所包含的页面。例如：

... 完成包含的JSP
+
----
<html><body>

<jsp:include page="Header.jsp" >
    <jsp:param name="subTitle" value="xxxxx" />
</jsp:include>

<br>
<em>Web Services Support Group.</em> <br><br>
Contact us at: ${initParam.mainEmail}
</body></html>
----

... 使用新参数的被包含页眉（Header.jsp）
+
----
<img src="images/Web-Services.jpg" > <br>
<em><strong>${param.subTitle}</strong></em> <br>
----

+
注意：这种使用参数的方法对于include指令没有意义（因为不是动态的），只适用于<jsp:include>标准动作。

. 利用<jsp:forward>标准动作有条件的转发

.. 提供转发条件的JSP（Hello.jsp）
+
----
<html><body>
Welcome to our page!
<% if (request.getParameter("userName") == null) { %>
    <jsp:forward page="HandleIt.jsp" />
<% } %>
Hello ${param.userName}
</body></html>
----

.. 请求转发到的目标JSP（HandleIt.jsp）
+
----
<html><body>
We're sorry... you need to log in again.

<form action="Hello.jsp" method="get">
Name: <input name="userName" type="text">
<input name="Submit" type="submit">
</form>

</body></html>
----

.. 注意：缓冲区会在转发前清空，不要先刷新输出（out.flush()）再转发。

.. 不用脚本就完成条件转发的例子（使用JSTL）：
+
----
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html><body>
Welcome to our page!

<c:if test="${empty param.userName}" >
    <jsp:forward page="HandleIt.jsp" />
</c:if>

Hello ${param.userName}
</body></html>
----


==== (四)JSTL



==== (五)定制标记开发



==== (六)Web应用部署



==== (七)Web应用安全



==== (八)过滤器和包装器



==== (九)模式和struts



=== 环境变量设置

. Java

.. JAVA_HOME
+
安装路径
+
注意：某些环境下引用 %JAVA_HOME% 可能出问题，例如 eclipse 下的 javadoc 。

.. CLASSPATH
+
----
.\;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar
----

.. PATH
+
----
;%JAVA_HOME%\bin;
----

. Tomcat

.. CATALINA_HOME
+
安装路径

.. CLASSPATH
+
----
.\;%CATALINA_HOME%\lib;
----

. Ant

.. ANT_HOME
+
安装路径

.. PATH
+
----
;%ANT_HOME%\bin;
----

=== 其他

. JavaBean

.. boolean属性命名时，应避免使用“is”开头。